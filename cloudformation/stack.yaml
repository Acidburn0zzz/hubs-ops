AWSTemplateFormatVersion: '2010-09-09'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Domain Setup
        Parameters:
          - DomainName
          - IsDomainOnRoute53
          - ShortlinkZone
          - InternalZone
      - Label:
          default: SSL Certificates
        Parameters:
          - UnmanagedDomainCertArn
      - Label:
          default: Advanced
        Parameters:
          - CIDR
    ParameterLabels:
      DomainName:
        default: Domain Name
      IsDomainOnRoute53:
        default: Is your domain set up on Route 53?
      ShortlinkZone:
        default: Short link Route 53 Zone
      InternalZone:
        default: Internal Route 53 Zone
      UnmanagedDomainCertArn:
        default: Unmanaged Domain SSL Certificate ARN
Parameters:
  DomainName:
    Type: String
    Description: Domain name WebSpaces will be hosted on. (eg mywebspaces.com or webspaces.mydomain.com.)
    AllowedPattern: ^((?:([a-z0-9]\.|[a-z0-9][a-z0-9\-]{0,61}[a-z0-9])\.)+)([a-z0-9]{2,63}|(?:[a-z0-9][a-z0-9\-]{0,61}[a-z0-9]))\.?$
    ConstraintDescription: Must be a valid domain name (eg mywebspaces.com or webspaces.mycompany.com)
  IsDomainOnRoute53:
    Type: String
    Description: It is hightly recommended you use Route 53 to manage your domain. Set to Yes if your domain is set up on Route 53. Set to No if your domain is on a third party service such as GoDaddy or Namecheap. If you choose 'No', you'll need to set the 'Unmanaged Domain SSL Certificate ARN' configuration setting in the 'SSL Certificates' section below. Also, if you choose 'No', once your stack is created you'll need to update your DNS provider using the information in the 'Outputs' tab. See the 'Outputs' tab once the stack is created for more information on what to do next.
    AllowedValues: ["Yes - My domain is set up on Route 53.", "No - My domain is not on Route 53 and I will set up my SSL certificate below in the 'SSL Certificates' section."]
  ShortlinkZone:
    Type: AWS::Route53::HostedZone::Id
    Description: Your AWS Route 53 Zone for short room permalinks and entry codes. (eg mywebspaces.link) It should *not* be the same domain as the any of th eWebSpaces domain names that you specified above. This domain will be used by visitors to share room links, and ideally should be short and easy to type.
    AllowedPattern: ".+"
    ConstraintDescription: You didn't specify a short link Route 53 Zone. Please choose one or create a new domain name on AWS on Route 53, ideally one short and easy to type.
  InternalZone:
    Type: AWS::Route53::HostedZone::Id
    Description: Your AWS Route 53 Zone for an internal domain name (eg mywebspaces-internal.com.) You'll need to register a new internal domain name of your choice with Route 53 to be used internally by WebSpaces. It should *not* be the same domain as the WebSpaces domain name that you specified above. This domain will not be seen by visitors and can be anything you like.
    AllowedPattern: ".+"
    ConstraintDescription: You didn't specify an internal Route 53 Zone. Please choose one or create a new domain name on AWS on Route 53. It can be anything you want and is used internally. It will not be seen by your visitors.
  UnmanagedDomainCertArn:
    Type: String
    Description: You can skip this if you chose 'Yes' above and your domain is set up on AWS Route 53. Otherwise, if you chose 'No' and you are using a domain name not managed by AWS Route 53 you will need to upload your domain's SSL certificate to AWS Certificate Manager. Make sure you upload it to the same region you are going to create your WebSpaces stack. Once you've uploaded the certificate, paste the ARN for the certificate here (eg arn:aws:acm:<region>:<account>:certificate/<id>). You can find the ARN by clicking on the certificate in the AWS Certificate Manager console.
    AllowedPattern: "^$|^arn:aws:acm:"
    ConstraintDescription: You must point to an ARN in AWS Certificate Manager for your domain.
  CIDR:
    Type: String
    Description: VPC CIDR block to use for internal server IPs.
    Default: 10.56.0.0/16

Conditions:
  HasMangedDomain: !Not [!Equals [!Ref IsDomainOnRoute53, "Yes - My domain is set up on Route 53"]]

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref CIDR
      InstanceTenancy: default
      EnableDnsSupport: 'true'
      EnableDnsHostnames: 'true'
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-vpc"
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-igw"
  LambdaBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: Private
      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-lambdas", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
      #  CopySpeelycaptorLambda:
      #    Type: Custom::CopySpeelycaptorLambda
      #    UpdateReplacePolicy: Retain
      #    DependsOn: LambdaBucket
      #    Properties:
      #      ServiceToken: !GetAtt 'CopyLambdaZipFunction.Arn'
      #      DestBucket: !Ref 'LambdaBucket'
      #      SourceBucket: assets.polycosm-prod-b99b35f30242f894
      #      Prefix: ""
      #      Objects:
      #        - lambdas/speelycaptor/speelycaptor-0.1.2.zip
      #  CopyNearsparkLambda:
      #    Type: Custom::CopyNearsparkLambda
      #    UpdateReplacePolicy: Retain
      #    DependsOn: LambdaBucket
      #    Properties:
      #      ServiceToken: !GetAtt 'CopyLambdaZipFunction.Arn'
      #      DestBucket: !Ref 'LambdaBucket'
      #      SourceBucket: assets.polycosm-prod-b99b35f30242f894
      #      Prefix: ""
      #      Objects:
      #        - lambdas/nearspark/nearspark-0.1.0.zip
      #  CopyPhotomnemonicLambda:
      #    Type: Custom::CopyPhotomnemonicLambda
      #    UpdateReplacePolicy: Retain
      #    DependsOn: LambdaBucket
      #    Properties:
      #      ServiceToken: !GetAtt 'CopyLambdaZipFunction.Arn'
      #      DestBucket: !Ref 'LambdaBucket'
      #      SourceBucket: assets.polycosm-prod-b99b35f30242f894
      #      Prefix: ""
      #      Objects:
      #        - lambdas/photomnemonic/photomnemonic-0.1.0.zip

# route53dependency
  Route53DependencyLambda:
    Metadata:
      Source: https://github.com/sonyxperiadev/amazon-custom-resources/tree/master/route53-dependency
      Version: 1.0.0
    Type: AWS::Lambda::Function
    Properties:
      Description: Lookup Route 53 info
      Handler: index.handler
      Role: !GetAtt 'Route53DependencyRole.Arn'
      Runtime: nodejs8.10
      Timeout: 900
      Code:
        ZipFile: |
          'use strict';

          function route53Dependency(properties, callback) {
            if (!properties.Id && !properties.Domain)
              callback("Zone id or domain not specified");

            var aws = require("aws-sdk");
            var route53 = new aws.Route53();

            var responseData = {};
            console.log('route53Dependency', properties);
            route53.listHostedZones({}, function(err, data) {
              console.log('listHostedZones', err, data);
              if (err)
                return callback(err);

              var zones = data.HostedZones;
              var matching = zones.filter(function(zone) {
                if (properties.Id) {
                  return zone.Id === "/hostedzone/" + properties.Id;
                } else {
                  var tldParts = properties.Domain.split(".");
                  var tld = tldParts[tldParts.length - 2] + "." + tldParts[tldParts.length - 1];
                  return zone.Name === tld + ".";
                }
              });
              if (matching.length != 1)
                return callback('Exactly one matching zone is allowed ' + zones);
              var match = matching[0];
              delete match.Config;
              delete match.CallerReference;
              match.Id = match.Id.split('/')[2];
              match.Name = match.Name.substring(0, match.Name.length-1);
              return callback(null, match);
            });
          }

          route53Dependency.handler = function(event, context) {
            console.log(JSON.stringify(event, null, '  '));

            if (event.RequestType == 'Delete') {
              return sendResponse(event, context, "SUCCESS");
            }

            route53Dependency(event.ResourceProperties, function(err, result) {
              var status = err ? 'FAILED' : 'SUCCESS';
              return sendResponse(event, context, status, result, err);
            });
          };

          function getReason(err) {
            if (err)
              return err.message;
            else
              return '';
          }

          function sendResponse(event, context, status, data, err) {
            var responseBody = {
              StackId: event.StackId,
              RequestId: event.RequestId,
              LogicalResourceId: event.LogicalResourceId,
              PhysicalResourceId: 'route53Dependency-' + event.ResourceProperties.DomainName,
              Status: status,
              Reason: getReason(err) + " See details in CloudWatch Log: " + context.logStreamName,
              Data: data
            };

            console.log("RESPONSE:\n", responseBody);
            var json = JSON.stringify(responseBody);

            var https = require("https");
            var url = require("url");

            var parsedUrl = url.parse(event.ResponseURL);
            var options = {
              hostname: parsedUrl.hostname,
              port: 443,
              path: parsedUrl.path,
              method: "PUT",
              headers: {
                "content-type": "",
                "content-length": json.length
              }
            };

            var request = https.request(options, function(response) {
              console.log("STATUS: " + response.statusCode);
              console.log("HEADERS: " + JSON.stringify(response.headers));
              context.done(null, data);
            });

            request.on("error", function(error) {
              console.log("sendResponse Error:\n", error);
              context.done(error);
            });

            request.on("end", function() {
              console.log("end");
            });
            request.write(json);
            request.end();
          }


          module.exports = route53Dependency;
  Route53DependencyRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - route53:ListHostedZones
                Effect: Allow
                Resource: "*"
            Version: '2012-10-17'
          PolicyName: !Sub '${AWS::StackName}Route53DependencyCustomPolicy'
    Type: AWS::IAM::Role

# CustomAcmCertificateLambda
  CustomAcmCertificateLambda:
    Metadata:
      Source: https://github.com/dflook/cloudformation-dns-certificate
      Version: 1.7.1
    Properties:
      Code:
        ZipFile: "T=RuntimeError\nimport copy,hashlib as t,json,logging as B,time\
          \ as b\nfrom boto3 import client as K\nfrom botocore.exceptions import ClientError\
          \ as u,ParamValidationError as v\nfrom botocore.vendored import requests\
          \ as w\nA=B.getLogger()\nA.setLevel(B.INFO)\nD=A.info\nS=A.exception\nd=json.dumps\n\
          M=copy.copy\ne=b.sleep\ndef handler(event,c):\n\tA9='OldResourceProperties';A8='Update';A7='Delete';A6='None';A5='acm';A4='FAILED';A3='properties';A2='stack-id';A1='logical-id';A0='DNS';s='Old';r='Certificate';q='LogicalResourceId';p='DomainName';o='ValidationMethod';n='Route53RoleArn';m='Region';a='RequestType';Z='Reinvoked';Y='StackId';X=None;R='Status';Q='Key';P='';O=True;N='DomainValidationOptions';L=False;J='ResourceProperties';I='cloudformation:';H='Value';G='CertificateArn';F='Tags';C='PhysicalResourceId';A=event;f=c.get_remaining_time_in_millis;D(A)\n\
          \tdef g():\n\t\tD=M(B)\n\t\tfor H in ['ServiceToken',m,F,n]:D.pop(H,X)\n\
          \t\tif o in B:\n\t\t\tif B[o]==A0:\n\t\t\t\tfor I in set([B[p]]+B.get('SubjectAlternativeNames',[])):k(I)\n\
          \t\t\t\tdel D[N]\n\t\tA[C]=E.request_certificate(IdempotencyToken=y,**D)[G];l()\n\
          \tdef U(a):\n\t\twhile O:\n\t\t\ttry:E.delete_certificate(**{G:a});return\n\
          \t\t\texcept u as B:\n\t\t\t\tS(P);A=B.response['Error']['Code']\n\t\t\t\
          \tif A=='ResourceInUseException':\n\t\t\t\t\tif f()/1000<30:raise\n\t\t\t\
          \t\te(5);continue\n\t\t\t\tif A in['ResourceNotFoundException','ValidationException']:return\n\
          \t\t\t\traise\n\t\t\texcept v:return\n\tdef V(props):\n\t\tfor J in E.get_paginator('list_certificates').paginate():\n\
          \t\t\tfor B in J['CertificateSummaryList']:\n\t\t\t\tD(B);C={A[Q]:A[H]for\
          \ A in E.list_tags_for_certificate(**{G:B[G]})[F]}\n\t\t\t\tif C.get(I+A1)==A[q]and\
          \ C.get(I+A2)==A[Y]and C.get(I+A3)==hash(props):return B[G]\n\tdef h():\n\
          \t\tif A.get(Z,L):raise T('Certificate not issued in time')\n\t\tA[Z]=O;D(A);K('lambda').invoke(FunctionName=c.invoked_function_arn,InvocationType='Event',Payload=d(A).encode())\n\
          \tdef i():\n\t\twhile f()/1000>30:\n\t\t\tB=E.describe_certificate(**{G:A[C]})[r];D(B)\n\
          \t\t\tif B[R]=='ISSUED':return O\n\t\t\telif B[R]==A4:raise T(B.get('FailureReason',P))\n\
          \t\t\te(5)\n\t\treturn L\n\tdef x():B=M(A[s+J]);B.pop(F,X);C=M(A[J]);C.pop(F,X);return\
          \ B!=C\n\tdef j():\n\t\tW='Type';V='Name';U='HostedZoneId';T='ValidationStatus';S='PENDING_VALIDATION';L='ResourceRecord'\n\
          \t\tif B.get(o)!=A0:return\n\t\twhile O:\n\t\t\tI=E.describe_certificate(**{G:A[C]})[r];D(I)\n\
          \t\t\tif I[R]!=S:return\n\t\t\tif not[A for A in I.get(N,[{}])if T not in\
          \ A or L not in A]:break\n\t\t\tb.sleep(1)\n\t\tfor F in I[N]:\n\t\t\tif\
          \ F[T]==S:M=k(F[p]);P=M.get(n,B.get(n));J=K('sts').assume_role(RoleArn=P,RoleSessionName=(r+A[q])[:64],DurationSeconds=900)['Credentials']if\
          \ P is not X else{};Q=K('route53',aws_access_key_id=J.get('AccessKeyId'),aws_secret_access_key=J.get('SecretAccessKey'),aws_session_token=J.get('SessionToken')).change_resource_record_sets(**{U:M[U],'ChangeBatch':{'Comment':'Domain\
          \ validation for '+A[C],'Changes':[{'Action':'UPSERT','ResourceRecordSet':{V:F[L][V],W:F[L][W],'TTL':60,'ResourceRecords':[{H:F[L][H]}]}}]}});D(Q)\n\
          \tdef k(n):\n\t\tC='.';n=n.rstrip(C);D={A[p].rstrip(C):A for A in B[N]};A=n.split(C)\n\
          \t\twhile len(A):\n\t\t\tif C.join(A)in D:return D[C.join(A)]\n\t\t\tA=A[1:]\n\
          \t\traise T(N+' missing'+' for '+n)\n\thash=lambda v:t.new('md5',d(v,sort_keys=O).encode()).hexdigest()\n\
          \tdef l():B=M(A[J].get(F,[]));B+=[{Q:I+A1,H:A[q]},{Q:I+A2,H:A[Y]},{Q:I+'stack-name',H:A[Y].split('/')[1]},{Q:I+A3,H:hash(A[J])}];E.add_tags_to_certificate(**{G:A[C],F:B})\n\
          \tdef W():D(A);B=w.put(A['ResponseURL'],json=A,headers={'content-type':P});B.raise_for_status()\n\
          \ttry:\n\t\ty=hash(A['RequestId']+A[Y]);B=A[J];E=K(A5,region_name=B.get(m));A[R]='SUCCESS'\n\
          \t\tif A[a]=='Create':\n\t\t\tif A.get(Z,L)is L:A[C]=A6;g()\n\t\t\tj()\n\
          \t\t\tif not i():return h()\n\t\telif A[a]==A7:\n\t\t\tif A[C]!=A6:\n\t\t\
          \t\tif A[C].startswith('arn:'):U(A[C])\n\t\t\t\telse:U(V(B))\n\t\telif A[a]==A8:\n\
          \t\t\tif x():\n\t\t\t\tD(A8)\n\t\t\t\tif V(B)==A[C]:\n\t\t\t\t\ttry:E=K(A5,region_name=A[A9].get(m));D(A7);U(V(A[A9]))\n\
          \t\t\t\t\texcept:S(P)\n\t\t\t\t\treturn W()\n\t\t\t\tif A.get(Z,L)is L:g()\n\
          \t\t\t\tj()\n\t\t\t\tif not i():return h()\n\t\t\telse:\n\t\t\t\tif F in\
          \ A[s+J]:E.remove_tags_from_certificate(**{G:A[C],F:A[s+J][F]})\n\t\t\t\t\
          l()\n\t\telse:raise T(A[a])\n\t\treturn W()\n\texcept Exception as z:S(P);A[R]=A4;A['Reason']=str(z);return\
          \ W()"
      Description: Cloudformation custom resource for DNS validated certificates
      Handler: index.handler
      Role: !GetAtt 'CustomAcmCertificateLambdaExecutionRole.Arn'
      Runtime: python3.6
      Timeout: 900
    Type: AWS::Lambda::Function
  CustomAcmCertificateLambdaExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action:
              - sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - acm:AddTagsToCertificate
                  - acm:DeleteCertificate
                  - acm:DescribeCertificate
                  - acm:RemoveTagsFromCertificate
                Effect: Allow
                Resource:
                  - !Sub 'arn:aws:acm:*:${AWS::AccountId}:certificate/*'
              - Action:
                  - acm:RequestCertificate
                  - acm:ListTagsForCertificate
                  - acm:ListCertificates
                Effect: Allow
                Resource:
                  - '*'
              - Action:
                  - route53:ChangeResourceRecordSets
                Effect: Allow
                Resource:
                  - arn:aws:route53:::hostedzone/*
            Version: '2012-10-17'
          PolicyName: !Sub '${AWS::StackName}CustomAcmCertificateLambdaExecutionPolicy'
    Type: AWS::IAM::Role

# Zones + SSL Certs
  ExternalZoneInfo:
    Type: Custom::Route53
    Properties:
      Domain: !Ref DomainName
      ServiceToken: !GetAtt 'Route53DependencyLambda.Arn'  

  ShortlinkZoneInfo:
    Type: Custom::Route53
    Condition: HasMangedDomain
    Properties:
      Id: !Ref ShortlinkZone
      ServiceToken: !GetAtt 'Route53DependencyLambda.Arn'  

  InternalZoneInfo:
    Type: Custom::Route53
    Condition: HasMangedDomain
    Properties:
      Id: !Ref InternalZone
      ServiceToken: !GetAtt 'Route53DependencyLambda.Arn'  

  ExternalZoneSSLCert:
    Type: Custom::DNSCertificate
    Condition: HasMangedDomain
    Properties: 
      DomainName:
        Fn::Join:
          - "."
          - - "*"
            - !GetAtt 'ExternalZoneInfo.Name'
      DomainValidationOptions:
        - DomainName: !GetAtt 'ExternalZoneInfo.Name'
          HostedZoneId: !GetAtt 'ExternalZoneInfo.Id'
      ValidationMethod: DNS
      Region: !Sub "${AWS::Region}"
      ServiceToken: !GetAtt 'CustomAcmCertificateLambda.Arn'  

  ShortlinkZoneSSLCert:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName:
        Fn::Join:
          - "."
          - - "*"
            - !GetAtt 'ShortlinkZoneInfo.Name'
      DomainValidationOptions:
        - DomainName: !GetAtt 'ShortlinkZoneInfo.Name'
          HostedZoneId: !GetAtt 'ShortlinkZoneInfo.Id'
      ValidationMethod: DNS
      Region: !Sub "${AWS::Region}"
      ServiceToken: !GetAtt 'CustomAcmCertificateLambda.Arn'  

  InternalZoneSSLCert:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName:
        Fn::Join:
          - "."
          - - "*"
            - !GetAtt 'InternalZoneInfo.Name'
      DomainValidationOptions:
        - DomainName: !GetAtt 'InternalZoneInfo.Name'
          HostedZoneId: !Ref InternalZone
      ValidationMethod: DNS
      Region: !Sub "${AWS::Region}"
      ServiceToken: !GetAtt 'CustomAcmCertificateLambda.Arn'  

  InternalZoneSSLCertEast:
    Type: Custom::DNSCertificate
    Properties: 
      DomainName:
        Fn::Join:
          - "."
          - - "*"
            - !GetAtt 'InternalZoneInfo.Name'
      DomainValidationOptions:
        - DomainName: !GetAtt 'InternalZoneInfo.Name'
          HostedZoneId: !Ref InternalZone
      ValidationMethod: DNS
      Region: us-east-1
      ServiceToken: !GetAtt 'CustomAcmCertificateLambda.Arn'  

# CopyLambdaZip
#  CopyLambdaZipRole:
#   Type: AWS::IAM::Role
#   Properties:
#     AssumeRolePolicyDocument:
#       Version: '2012-10-17'
#       Statement:
#         - Effect: Allow
#           Principal:
#             Service: lambda.amazonaws.com
#           Action: sts:AssumeRole
#     ManagedPolicyArns:
#       - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
#     Path: /
#     Policies:
#       - PolicyName: copy-lambda-zip
#         PolicyDocument:
#           Version: '2012-10-17'
#           Statement:
#             - Effect: Allow
#               Action:
#                 - s3:PutObject
#                 - s3:DeleteObject
#               Resource:
#                 - !Sub 'arn:aws:s3:::${LambdaBucket}/*'
#
#  CopyLambdaZipFunction:
#    Type: AWS::Lambda::Function
#    Properties:
#      Handler: index.handler
#      Runtime: python2.7
#      Role: !GetAtt 'CopyLambdaZipRole.Arn'
#      Timeout: 240
#      Code:
#        ZipFile: |
#          import json
#          import logging
#          import threading
#          import boto3
#          import cfnresponse
#          def copy_objects(source_bucket, dest_bucket, prefix, objects):
#              s3 = boto3.client('s3')
#              for o in objects:
#                  key = prefix + o
#                  copy_source = {
#                      'Bucket': source_bucket,
#                      'Key': key
#                  }
#                  print('copy_source: %s' % copy_source)
#                  print('dest_bucket = %s'%dest_bucket)
#                  print('key = %s' %key)
#                  s3.copy_object(CopySource=copy_source, Bucket=dest_bucket,
#                        Key=key)
#          def delete_objects(bucket, prefix, objects):
#              s3 = boto3.client('s3')
#              objects = {'Objects': [{'Key': prefix + o} for o in objects]}
#              s3.delete_objects(Bucket=bucket, Delete=objects)
#          def timeout(event, context):
#              logging.error('Execution is about to time out, sending failure response to CloudFormation')
#              cfnresponse.send(event, context, cfnresponse.FAILED, {}, None)
#          def handler(event, context):
#              # make sure we send a failure to CloudFormation if the function
#              # is going to timeout
#              timer = threading.Timer((context.get_remaining_time_in_millis()
#                        / 1000.00) - 0.5, timeout, args=[event, context])
#              timer.start()
#              print('Received event: %s' % json.dumps(event))
#              status = cfnresponse.SUCCESS
#              try:
#                  source_bucket = event['ResourceProperties']['SourceBucket']
#                  dest_bucket = event['ResourceProperties']['DestBucket']
#                  prefix = event['ResourceProperties']['Prefix']
#                  objects = event['ResourceProperties']['Objects']
#                  if event['RequestType'] == 'Delete':
#                      delete_objects(dest_bucket, prefix, objects)
#                  else:
#                      copy_objects(source_bucket, dest_bucket, prefix, objects)
#              except Exception as e:
#                  logging.error('Exception: %s' % e, exc_info=True)
#                  status = cfnresponse.FAILED
#              finally:
#                  timer.cancel()
#                  cfnresponse.send(event, context, status, {}, None)
#
## Speelycaptor
#  SpeelycaptorInitLogGroup:
#    Type: AWS::Logs::LogGroup
#    Properties:
#      LogGroupName: /aws/lambda/speelycaptor-initialize
#  SpeelycaptorConvertLogGroup:
#    Type: AWS::Logs::LogGroup
#    Properties:
#      LogGroupName: /aws/lambda/speelycaptor-convert
#  SpeelycaptorScratchBucket:
#    Type: AWS::S3::Bucket
#    Properties:
#      AccessControl: Private
#      BucketName: !Join ["-", [ !Sub "${AWS::StackName}-speelycaptor-scratch", !Select [0, !Split [ "-", !Select [2, !Split ["/", !Ref "AWS::StackId"]]]]]]
#  SpeelycaptorRole:
#    Type: AWS::IAM::Role
#    Properties:
#      AssumeRolePolicyDocument:
#        Version: '2012-10-17'
#        Statement:
#        - Effect: Allow
#          Principal:
#            Service:
#            - lambda.amazonaws.com
#          Action:
#          - sts:AssumeRole
#          Sid: ""
#      Path: "/"
#  SpeelycaptorRolePolicy:
#    Type: AWS::IAM::Policy
#    Properties:
#      PolicyName: "speelycaptor-policy"
#      Roles:
#        - !Ref SpeelycaptorRole
#      PolicyDocument:
#        Version: "2012-10-17"
#        Statement:
#          - Effect: Allow
#            Action: s3:GetObject
#            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
#          - Effect: Allow
#            Action: s3:PutObject
#            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
#          - Effect: Allow
#            Action: s3:PutObjectAcl
#            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
#          - Effect: Allow
#            Action: s3:GetObject
#            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}/*"
#          - Effect: Allow
#            Action: s3:ListBucket
#            Resource: !Sub "${SpeelycaptorScratchBucket.Arn}"
#          - Effect: Allow
#            Action: 
#              - ec2:DescribeInstances
#              - ec2:CreateNetworkInterface
#              - ec2:AttachNetworkInterface
#              - ec2:DescribeNetworkInterfaces
#              - ec2:DeleteNetworkInterface
#              - autoscaling:CompleteLifecycleAction
#            Resource: "*"
#          - Effect: Allow
#            Action:
#              - logs:CreateLogGroup
#              - logs:CreateLogStream
#              - logs:PutLogEvents
#            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
#  SpeelycaptorInitLambdaFunction:
#    Type: AWS::Lambda::Function
#    Properties:
#      Code:
#        S3Bucket: !Ref LambdaBucket
#        S3Key: lambdas/speelycaptor/speelycaptor-0.1.2.zip
#      FunctionName: speelycaptor-initialize
#      Handler: index.init
#      MemorySize: 1024
#      Role: !GetAtt SpeelycaptorRole.Arn
#      Runtime: nodejs10.x
#      Timeout: 120
#      Environment:
#        Variables:
#          scratchBucketRegion: !Ref "AWS::Region"
#          scratchBucketId: !Ref SpeelycaptorScratchBucket
#    DependsOn:
#      - SpeelycaptorInitLogGroup
#      - CopySpeelycaptorLambda
#  SpeelycaptorConvertLambdaFunction:
#    Type: AWS::Lambda::Function
#    Properties:
#      Code:
#        S3Bucket: !Ref LambdaBucket
#        S3Key: lambdas/speelycaptor/speelycaptor-0.1.2.zip
#      FunctionName: speelycaptor-convert
#      Handler: index.convert
#      MemorySize: 3000
#      Role: !GetAtt SpeelycaptorRole.Arn
#      Runtime: nodejs10.x
#      Timeout: 120
#      Environment:
#        Variables:
#          scratchBucketRegion: !Ref "AWS::Region"
#          scratchBucketId: !Ref SpeelycaptorScratchBucket
#    DependsOn:
#      - SpeelycaptorConvertLogGroup
#      - CopySpeelycaptorLambda
#  SpeelycaptorApiGatewayRestApi:
#    Type: AWS::ApiGateway::RestApi
#    Properties:
#      Name: speelycaptor
#      EndpointConfiguration:
#        Types:
#          - EDGE
#  SpeelycaptorApiGatewayResourceInit:
#    Type: AWS::ApiGateway::Resource
#    Properties:
#      ParentId: !GetAtt SpeelycaptorApiGatewayRestApi.RootResourceId
#      PathPart: init
#      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
#  SpeelycaptorApiGatewayResourceConvert:
#    Type: AWS::ApiGateway::Resource
#    Properties:
#      ParentId: !GetAtt SpeelycaptorApiGatewayRestApi.RootResourceId
#      PathPart: convert
#      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
#  SpeelycaptorApiGatewayMethodInitGet:
#    Type: AWS::ApiGateway::Method
#    Properties:
#      HttpMethod: GET
#      RequestParameters: {}
#      ResourceId: !Ref SpeelycaptorApiGatewayResourceInit
#      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
#      ApiKeyRequired: false
#      AuthorizationType: NONE
#      Integration:
#        IntegrationHttpMethod: POST
#        Type: AWS_PROXY
#        Uri: !Sub 'arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SpeelycaptorInitLambdaFunction.Arn}/invocations'
#      MethodResponses: []
#  SpeelycaptorApiGatewayMethodConvertGet:
#    Type: AWS::ApiGateway::Method
#    Properties:
#      HttpMethod: GET
#      RequestParameters: {}
#      ResourceId: !Ref SpeelycaptorApiGatewayResourceConvert
#      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
#      ApiKeyRequired: false
#      AuthorizationType: NONE
#      Integration:
#        IntegrationHttpMethod: POST
#        Type: AWS_PROXY
#        Uri: !Sub 'arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SpeelycaptorConvertLambdaFunction.Arn}/invocations'
#      MethodResponses: []
#  SpeelycaptorApiGatewayDeployment:
#    Type: AWS::ApiGateway::Deployment
#    Properties:
#      RestApiId: !Ref SpeelycaptorApiGatewayRestApi
#      StageName: prod
#    DependsOn:
#      - SpeelycaptorApiGatewayMethodInitGet
#      - SpeelycaptorApiGatewayMethodConvertGet
#  SpeelycaptorInitLambdaPermissionApiGateway:
#    Type: AWS::Lambda::Permission
#    Properties:
#      FunctionName: !GetAtt SpeelycaptorInitLambdaFunction.Arn
#      Action: lambda:InvokeFunction
#      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
#      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${SpeelycaptorApiGatewayRestApi}/*/*'
#  SpeelycaptorConvertLambdaPermissionApiGateway:
#    Type: AWS::Lambda::Permission
#    Properties:
#      FunctionName: !GetAtt SpeelycaptorConvertLambdaFunction.Arn
#      Action: lambda:InvokeFunction
#      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
#      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${SpeelycaptorApiGatewayRestApi}/*/*'
#
## Photomnemonic
#  PhotomnemonicRole:
#    Type: AWS::IAM::Role
#    Properties:
#      AssumeRolePolicyDocument:
#        Version: '2012-10-17'
#        Statement:
#        - Effect: Allow
#          Principal:
#            Service:
#            - lambda.amazonaws.com
#          Action:
#          - sts:AssumeRole
#          Sid: ""
#      Path: "/"
#  PhotomnemonicScreenshotLogGroup:
#    Type: AWS::Logs::LogGroup
#    Properties:
#      LogGroupName: /aws/lambda/photomnemonic-screenshot
#  PhotomnemonicRolePolicy:
#    Type: AWS::IAM::Policy
#    Properties:
#      PolicyName: "photomnemonic-policy"
#      Roles:
#        - !Ref PhotomnemonicRole
#      PolicyDocument:
#        Version: "2012-10-17"
#        Statement:
#          - Effect: Allow
#            Action: 
#              - ec2:DescribeInstances
#              - ec2:CreateNetworkInterface
#              - ec2:AttachNetworkInterface
#              - ec2:DescribeNetworkInterfaces
#              - ec2:DeleteNetworkInterface
#              - autoscaling:CompleteLifecycleAction
#            Resource: "*"
#          - Effect: Allow
#            Action:
#              - logs:CreateLogGroup
#              - logs:CreateLogStream
#              - logs:PutLogEvents
#            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
#  PhotomnemonicScreenshotLambdaFunction:
#    Type: AWS::Lambda::Function
#    Properties:
#      Code:
#        S3Bucket: !Ref LambdaBucket
#        S3Key: lambdas/photomnemonic/photomnemonic-0.1.0.zip
#      FunctionName: photomnemonic-screenshot
#      Handler: index.handler
#      MemorySize: 1024
#      Role: !GetAtt PhotomnemonicRole.Arn
#      Runtime: nodejs8.10
#      Timeout: 30
#    DependsOn:
#      - CopyPhotomnemonicLambda
#      - PhotomnemonicScreenshotLogGroup
#  PhotomnemonicApiGatewayRestApi:
#    Type: AWS::ApiGateway::RestApi
#    Properties:
#      Name: photomnemonic
#      BinaryMediaTypes:
#        - "*/*"
#      EndpointConfiguration:
#        Types:
#          - EDGE
#      Body:
#        swagger: 2.0
#        paths:
#          "/screenshot":
#            get:
#              parameters:
#                - name: url
#                  in: query
#                  required: true
#              x-amazon-apigateway-binary-media-types:
#                - "*/*"
#              x-amazon-apigateway-integration:
#                httpMethod: POST
#                responses:
#                  contentHandling: CONVERT_TO_BINARY,
#                type: aws_proxy
#                contentHandling: CONVERT_TO_BINARY
#                uri:
#                  Fn::Sub: arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PhotomnemonicScreenshotLambdaFunction.Arn}/invocations
#  PhotomnemonicApiGatewayDeployment:
#    Type: AWS::ApiGateway::Deployment
#    Properties:
#      RestApiId: !Ref PhotomnemonicApiGatewayRestApi
#      StageName: prod
#    DependsOn:
#      - PhotomnemonicApiGatewayRestApi
#  PhotomnemonicScreenshotLambdaPermissionApiGateway:
#    Type: AWS::Lambda::Permission
#    Properties:
#      FunctionName: !GetAtt PhotomnemonicScreenshotLambdaFunction.Arn
#      Action: lambda:InvokeFunction
#      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
#      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${PhotomnemonicApiGatewayRestApi}/*/*'
#
## Nearspark
#  NearsparkRole:
#    Type: AWS::IAM::Role
#    Properties:
#      AssumeRolePolicyDocument:
#        Version: '2012-10-17'
#        Statement:
#        - Effect: Allow
#          Principal:
#            Service:
#            - lambda.amazonaws.com
#          Action:
#          - sts:AssumeRole
#          Sid: ""
#      Path: "/"
#  NearsparkThumbnailLogGroup:
#    Type: AWS::Logs::LogGroup
#    Properties:
#      LogGroupName: /aws/lambda/nearspark-thumbnail
#  NearsparkRolePolicy:
#    Type: AWS::IAM::Policy
#    Properties:
#      PolicyName: "nearspark-policy"
#      Roles:
#        - !Ref NearsparkRole
#      PolicyDocument:
#        Version: "2012-10-17"
#        Statement:
#          - Effect: Allow
#            Action: 
#              - ec2:DescribeInstances
#              - ec2:CreateNetworkInterface
#              - ec2:AttachNetworkInterface
#              - ec2:DescribeNetworkInterfaces
#              - ec2:DeleteNetworkInterface
#              - autoscaling:CompleteLifecycleAction
#            Resource: "*"
#          - Effect: Allow
#            Action:
#              - logs:CreateLogGroup
#              - logs:CreateLogStream
#              - logs:PutLogEvents
#            Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*:*"
#  NearsparkThumbnailLambdaFunction:
#    Type: AWS::Lambda::Function
#    Properties:
#      Code:
#        S3Bucket: !Ref LambdaBucket
#        S3Key: lambdas/nearspark/nearspark-0.1.0.zip
#      FunctionName: nearspark-thumbnail
#      Handler: index.handler
#      MemorySize: 128
#      Role: !GetAtt NearsparkRole.Arn
#      Runtime: nodejs10.x
#      Timeout: 30
#    DependsOn:
#      - CopyNearsparkLambda
#      - NearsparkThumbnailLogGroup
#  NearsparkApiGatewayRestApi:
#    Type: AWS::ApiGateway::RestApi
#    Properties:
#      Name: nearspark
#      BinaryMediaTypes:
#        - "*/*"
#      EndpointConfiguration:
#        Types:
#          - EDGE
#      Body:
#        swagger: 2.0
#        paths:
#          "/thumbnail/{url}":
#            get:
#              consumes:
#                - "application/json"
#              parameters:
#                - name: url
#                  in: path
#                  required: true
#                  type: string
#                - name: width
#                  in: query
#                  required: true
#                  type: number
#                - name: height
#                  in: query
#                  required: true
#                  type: number
#                - name: fit
#                  in: query
#                  required: false
#                  type: string
#                - name: position
#                  in: query
#                  required: false
#                  type: string
#                - name: gravity
#                  in: query
#                  required: false
#                  type: string
#                - name: strategy
#                  in: query
#                  required: false
#                  type: string
#                - name: background
#                  in: query
#                  required: false
#                  type: string
#                - name: withoutEnlargement
#                  in: query
#                  required: false
#                  type: boolean
#              requestTemplates:
#                "application/json": "{\"url\": \"$input.params('url')\"}"
#              x-amazon-apigateway-binary-media-types:
#                - "*/*"
#              x-amazon-apigateway-integration:
#                httpMethod: POST
#                responses:
#                  contentHandling: CONVERT_TO_BINARY,
#                type: aws_proxy
#                contentHandling: CONVERT_TO_BINARY
#                uri:
#                  Fn::Sub: arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${NearsparkThumbnailLambdaFunction.Arn}/invocations
#  NearsparkApiGatewayDeployment:
#    Type: AWS::ApiGateway::Deployment
#    Properties:
#      RestApiId: !Ref NearsparkApiGatewayRestApi
#      StageName: prod
#    DependsOn:
#      - NearsparkApiGatewayRestApi
#  NearsparkThumbnailLambdaPermissionApiGateway:
#    Type: AWS::Lambda::Permission
#    Properties:
#      FunctionName: !GetAtt NearsparkThumbnailLambdaFunction.Arn
#      Action: lambda:InvokeFunction
#      Principal: !Sub 'apigateway.${AWS::URLSuffix}'
#      SourceArn: !Sub 'arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${NearsparkApiGatewayRestApi}/*/*'
#  NearsparkCloudfrontDNS:
#    Type: AWS::Route53::RecordSet
#    Properties:
#      Name:
#        Fn::Join:
#          - "."
#          - - nearspark
#            - !GetAtt 'InternalZoneInfo.Name'
#      HostedZoneId: !Ref InternalZone
#      Type: A
#      AliasTarget:
#        DNSName:
#          Fn::GetAtt: [ NearsparkCloudfrontDistribution, DomainName ]
#        HostedZoneId: Z2FDTNDATAQYW2
#
#  NearsparkCloudfrontDistribution:
#    Type: AWS::CloudFront::Distribution
#    Properties:
#      DistributionConfig:
#        Origins:
#          - Id: ApiGateway
#            DomainName:
#              Fn::Join:
#                - ""
#                - - Ref: NearsparkApiGatewayRestApi
#                  - ".execute-api."
#                  - Ref: AWS::Region
#                  - ".amazonaws.com"
#            CustomOriginConfig:
#              HTTPPort: 80
#              HTTPSPort: 443
#              OriginProtocolPolicy: https-only
#              OriginSSLProtocols: [ "TLSv1", "TLSv1.1", "TLSv1.2" ]
#            OriginPath: "/prod"
#        Enabled: true
#        HttpVersion: http2
#        PriceClass: PriceClass_All
#        Aliases:
#          -
#            Fn::Join:
#              - "."
#              - - nearspark
#                - !GetAtt 'InternalZoneInfo.Name'
#        DefaultCacheBehavior:
#          AllowedMethods:
#            - GET
#            - HEAD
#            - OPTIONS
#          CachedMethods:
#            - GET
#            - HEAD
#          TargetOriginId: ApiGateway
#          ForwardedValues:
#            QueryString: true
#            Headers: []
#            Cookies:
#              Forward: none
#          ViewerProtocolPolicy: redirect-to-https
#          MinTTL: '0'
#          DefaultTTL: '3600'
#        ViewerCertificate:
#          AcmCertificateArn: !Ref InternalZoneSSLCertEast
#          SslSupportMethod: sni-only

# Base
#  BasePolicy:
#    Type: AWS::IAM::Policy
#    Properties:
#      PolicyName: !Sub "${AWS::StackName}-base-policy"
#      PolicyBody:
#        Version: 2012-10-17
#        Statement:
#          - Effect: Allow,
#            Action: ec2:DescribeInstances
#            Resource: "*"
#          - Effect: Allow
#            Action: ec2:CreateTags
#            Resource: "*"
#          - Effect: Allow
#            Action: ec2:DescribeTags
#            Resource: "*"
#          - Effect: Allow
#            Action:
#            - ssm:DescribeAssociation
#            - ssm:GetDeployablePatchSnapshotForInstance
#            - ssm:GetDocument
#            - ssm:DescribeDocument
#            - ssm:GetManifest
#            - ssm:GetParameters
#            - ssm:ListAssociations
#            - ssm:ListInstanceAssociations
#            - ssm:PutInventory
#            - ssm:PutComplianceItems
#            - ssm:PutConfigurePackageResult
#            - ssm:UpdateAssociationStatus
#            - ssm:UpdateInstanceAssociationStatus
#            - ssm:UpdateInstanceInformation
#            Resource: "*"
#          - Effect: Allow
#            Action:
#            - ssmmessages:CreateControlChannel
#            - ssmmessages:CreateDataChannel
#            - ssmmessages:OpenControlChannel
#            - ssmmessages:OpenDataChannel
#            Resource: "*"
#          - Effect: Allow
#            Action:
#            - ec2messages:AcknowledgeMessage
#            - ec2messages:DeleteMessage
#            - ec2messages:FailMessage
#            - ec2messages:GetEndpoint
#            - ec2messages:GetMessages
#            - ec2messages:SendReply
#            Resource: "*"
#          - Effect: Allow
#            Action: route53:ChangeResourceRecordSets
#            Resource: arn:aws:route53:::hostedzone/Z26OTGLBBCAHK4

          #Outputs:
          #  SpeelycaptorServiceEndpoint:
          #    Description: URL of the speelycaptor service endpoint
          #    Value: !Sub 'https://${SpeelycaptorApiGatewayRestApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/prod'
          #
          #  PhotomnemonicServiceEndpoint:
          #    Description: URL of the photomnemonic service endpoint
          #    Value: !Sub 'https://${PhotomnemonicApiGatewayRestApi}.execute-api.${AWS::Region}.${AWS::URLSuffix}/prod'
